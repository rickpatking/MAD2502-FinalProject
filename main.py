import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
from heapq import heapify, heappop, heappush

# Example
sites = np.array([[1,0], [4,2.5], [1,5], [7.5,4]])
start = np.array([5,6])
stop = np.array([6,0])
vor = Voronoi(sites)

def voronoi_plotter(start: np.ndarray, stop: np.ndarray, vor: Voronoi) -> None:
    """
    Takes the input of a starting point, ending point, and a Voronoi class.
    The voronoi diagram along with the start and end points are displayed using matplotlib.
    :param start: A 1d numpy array containing a starting point
    :param stop: A 1d numpy array containing an ending point
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :return: Nothing is returned
    """
    fig, ax = plt.subplots()
    plt.plot(start[0], start[1], 'bo')
    plt.plot(stop[0], stop[1], 'ro')
    voronoi_plot_2d(vor, ax=ax)
    plot_max = max(start[1], stop[1])
    plot_min = min(start[1], stop[1])
    plt.ylim([plot_min-3, plot_max+3])
    plt.show()

def helper_distance(point1, point2):
    distance = ((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)**0.5
    return distance

def point_in_region(point: np.ndarray, vor: Voronoi) -> tuple:
    """
    Takes the input of a 1d numpy array in the form of [1,0] as a point and a Voronoi class that represents a voronoi diagram.
    The function will return a 1d tuple that holds the site closest to the entered point
    and the region number that the entered point is in. This is in the form of (site, region #).
    :param point: A point in the form of 1d numpy array
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :return: Returns a tuple containing the site and region number that the entered point is in
    """
    distance = []
    count = 0
    for site in vor.points:
        current_distance = helper_distance(point, [site[0], site[1]])
        distance.append([current_distance, [site[0], site[1]], count])
        count += 1
    min_distance = distance[0][0]
    for sub_list in distance:
        if sub_list[0] < min_distance:
            min_distance = sub_list[0]
    for array in distance:
        if array[0] == min_distance:
            cell_point = array[1]
            cell_point_number = array[2]
    return (cell_point, vor.point_region[cell_point_number])

def build_weighted_graph(vor: Voronoi, sites: np.ndarray) -> dict:
    """
    Constructs a weighted graph based on the provided Voronoi diagram.
    Each node corresponds to a Voronoi vertex, and the weight of an edge between two nodes is computed
    as the Euclidean distance between the vertices plus a clearance penalty.
    The penalty is inversely proportional to the clearance from the sitesâ€”edges whose midpoints are close
    to any site incur a higher cost.

    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :param sites: A 2d numpy array of site coordinates used to generate the Voronoi diagram.
    :return: A dictionary representing the weighted graph, with keys as vertex indices and values as lists of (neighbor_index, weight).
    """
    graph = {}
    epsilon = 1e-6

    for ridge in vor.ridge_vertices:
        if -1 in ridge:
            continue

        p1 = vor.vertices[ridge[0]]
        p2 = vor.vertices[ridge[1]]
        edge_length = np.linalg.norm(p1 - p2)
        midpoint = (p1 + p2) / 2.0

        clearance = min(np.linalg.norm(midpoint - site) for site in sites)
        clearance = max(clearance, epsilon)

        final_weight = edge_length + (1.0 / clearance)

        graph.setdefault(ridge[0], []).append((ridge[1], final_weight))
        graph.setdefault(ridge[1], []).append((ridge[0], final_weight))

    return graph

def closest_vertex(point: np.ndarray, vor: Voronoi) -> list:
    """
    Finds the closest voronoi vertex to a point. Returns a list containing a numpy array of the vertex point in the first index
    and the vertex number in the second index.
    :param point: A point in the form of a numpy array
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi
    :return: A list that contains the vertex point and number
    """
    closest_vertex = min([[helper_distance(point, vertex), vertex, ind] for ind, vertex in enumerate(vor.vertices)])
    return (closest_vertex[1], closest_vertex[2])

def dijkstra(start_vertex: int, stop_vertex: int, vor: Voronoi) -> list:
    """
    Computes the shortest path along the ridges of the voronoi diagram from the start_vertex to the stop_vertex.
    The path is returned as a list where the first index is the starting vertex and each subsequent index is the next vertex
    to be traveled to, ending with the stopping vertex.
    :param start_vertex: An integer corresponding with the number of the starting vertex
    :param stop_vertex: An integer corresponding with the number of the stopping vertex
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi
    :return: A list of the path to be travelled
    """
    distances = {node: float('inf') for node, vertex in enumerate(vor.vertices)}
    distances[start_vertex] = 0
    pq = [(0, start_vertex)]
    heapify(pq)
    visited = set()

    connected_vertices = {}
    for vertex_pair in vor.ridge_vertices:
        vertex1, vertex2 = vertex_pair
        if vertex1 == -1 or vertex2 == -1:
            continue
        connected_vertices.setdefault(vertex1, {}).setdefault(vertex2, helper_distance(vor.vertices[vertex1], vor.vertices[vertex2]))
        connected_vertices.setdefault(vertex2, {}).setdefault(vertex1, helper_distance(vor.vertices[vertex2], vor.vertices[vertex1]))

    while pq:
        current_distance, current_node = heappop(pq)
        if current_node in visited:
            continue
        visited.add(current_node)

        for neighbor, weight in connected_vertices[current_node].items():
            tent_distance = current_distance + weight
            if tent_distance < distances[neighbor]:
                distances[neighbor] = tent_distance
                heappush(pq, (tent_distance, neighbor))

    pre = {node: None for node, vertex in enumerate(vor.vertices)}

    for node, distance in distances.items():
        for neighbor, weight in connected_vertices[node].items():
            if distances[neighbor] == distance + weight:
                pre[neighbor] = node

    path = []
    current_node = stop_vertex

    while current_node:
        path.append(current_node)
        current_node = pre[current_node]

    path.reverse()
    path.append(start_vertex)
    return path