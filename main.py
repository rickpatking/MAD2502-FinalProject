import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt

# Example
sites = np.array([[1,0], [4,2.5], [1,5], [7.5,4]])
start = np.array([5,6])
stop = np.array([6,0])
vor = Voronoi(sites)

def voronoi_plotter(start: np.ndarray, stop: np.ndarray, vor: Voronoi) -> None:
    """
    Takes the input of a starting point, ending point, and a Voronoi class.
    The voronoi diagram along with the start and end points are displayed using matplotlib.
    :param start: A 1d numpy array containing a starting point
    :param stop: A 1d numpy array containing an ending point
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :return: Nothing is returned
    """
    fig, ax = plt.subplots()
    plt.plot(start[0], start[1], 'bo')
    plt.plot(stop[0], stop[1], 'ro')
    voronoi_plot_2d(vor, ax=ax)
    plot_max = max(start[1], stop[1])
    plot_min = min(start[1], stop[1])
    plt.ylim([plot_min-3, plot_max+3])
    plt.show()

def point_in_region(point: np.ndarray, vor: Voronoi) -> tuple:
    """
    Takes the input of a 1d numpy array in the form of [1,0] as a point and a Voronoi class that represents a voronoi diagram.
    The function will return a 1d tuple that holds the site closest to the entered point
    and the region number that the entered point is in. This is in the form of (site, region #).
    :param point: A point in the form of 1d numpy array
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :return: Returns a tuple containing the site and region number that the entered point is in
    """
    def helper_distance(point1, point2):
        distance = ((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)**0.5
        return distance
    distance = []
    count = 0
    for site in vor.points:
        current_distance = helper_distance(point, [site[0], site[1]])
        distance.append([current_distance, [site[0], site[1]], count])
        count += 1
    min_distance = distance[0][0]
    for sub_list in distance:
        if sub_list[0] < min_distance:
            min_distance = sub_list[0]
    for array in distance:
        if array[0] == min_distance:
            cell_point = array[1]
            cell_point_number = array[2]
    return (cell_point, vor.point_region[cell_point_number])

def build_weighted_graph(vor: Voronoi, sites: np.ndarray) -> dict:
    """
    Constructs a weighted graph based on the provided Voronoi diagram.
    Each node corresponds to a Voronoi vertex, and the weight of an edge between two nodes is computed
    as the Euclidean distance between the vertices plus a clearance penalty.
    The penalty is inversely proportional to the clearance from the sitesâ€”edges whose midpoints are close
    to any site incur a higher cost.

    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :param sites: A 2d numpy array of site coordinates used to generate the Voronoi diagram.
    :return: A dictionary representing the weighted graph, with keys as vertex indices and values as lists of (neighbor_index, weight).
    """
    graph = {}
    epsilon = 1e-6

    for ridge in vor.ridge_vertices:
        if -1 in ridge:
            continue

        p1 = vor.vertices[ridge[0]]
        p2 = vor.vertices[ridge[1]]
        edge_length = np.linalg.norm(p1 - p2)
        midpoint = (p1 + p2) / 2.0

        clearance = min(np.linalg.norm(midpoint - site) for site in sites)
        clearance = max(clearance, epsilon)

        final_weight = edge_length + (1.0 / clearance)

        graph.setdefault(ridge[0], []).append((ridge[1], final_weight))
        graph.setdefault(ridge[1], []).append((ridge[0], final_weight))

    return graph