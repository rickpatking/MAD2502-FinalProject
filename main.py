import numpy as np
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
from heapq import heapify, heappop, heappush
from load_risk_path_from_csv import load_risk_path_from_csv
from export_csv import export_risk_path_to_csv


# Example
sites = np.array([[1,0], [4,2.5], [1,5], [7.5,4], [5, 6], [5,2], [2, 5], [3.2, 5.3]])
start = np.array([4, 7])
stop = np.array([6,0])
vor = Voronoi(sites)
rescue_time = True

def voronoi_plotter(start: np.ndarray, stop: np.ndarray, vor: Voronoi, sites: np.ndarray, padding: float=0.1) -> None:
    """
    Takes the input of a starting point, ending point, and a Voronoi class.
    The voronoi diagram along with the start and end points are displayed using matplotlib.
    :param start: A 1d numpy array containing a starting point
    :param stop: A 1d numpy array containing an ending point
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :param sites: A 2d numpy array of site coordinates
    :param padding: A float used to pad the edges of the plot
    :return: Nothing is returned
    """
    fig, ax = plt.subplots()
    plt.plot(start[0], start[1], 'bo')
    plt.plot(stop[0], stop[1], 'ro')
    voronoi_plot_2d(vor, ax=ax)

    x_vals = list(vor.vertices[:, 0]) + [pt[0] for pt in sites.tolist()]
    y_vals = list(vor.vertices[:, 1]) + [pt[1] for pt in sites.tolist()]

    x_min, x_max = min(x_vals), max(x_vals)
    y_min, y_max = min(y_vals), max(y_vals)

    x_pad = (x_max - x_min) * padding
    y_pad = (y_max - y_min) * padding

    ax.set_xlim(x_min - x_pad, x_max + x_pad)
    ax.set_ylim(y_min - y_pad, y_max + y_pad)

    plt.show()

def helper_distance(point1, point2):
    distance = ((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)**0.5
    return distance

def point_in_region(point: np.ndarray, vor: Voronoi) -> tuple:
    """
    Takes the input of a 1d numpy array in the form of [1,0] as a point and a Voronoi class that represents a voronoi diagram.
    The function will return a 1d tuple that holds the site closest to the entered point
    and the region number that the entered point is in. This is in the form of (site, region #).
    :param point: A point in the form of 1d numpy array
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :return: Returns a tuple containing the site and region number that the entered point is in
    """
    distance = []
    count = 0
    for site in vor.points:
        current_distance = helper_distance(point, [site[0], site[1]])
        distance.append([current_distance, [site[0], site[1]], count])
        count += 1
    min_distance = distance[0][0]
    for sub_list in distance:
        if sub_list[0] < min_distance:
            min_distance = sub_list[0]
    for array in distance:
        if array[0] == min_distance:
            cell_point = array[1]
            cell_point_number = array[2]
    return (cell_point, vor.point_region[cell_point_number])

def build_weighted_graph(vor: Voronoi, sites: np.ndarray, rescue_time: bool=True) -> dict:
    """
    Constructs a weighted graph based on the provided Voronoi diagram.
    Each node corresponds to a Voronoi vertex, and the weight of an edge between two nodes is computed
    as the Euclidean distance between the vertices plus a clearance penalty.
    The penalty is inversely proportional to the clearance from the sitesâ€”edges whose midpoints are close
    to any site incur a higher cost.

    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi.
    :param sites: A 2d numpy array of site coordinates used to generate the Voronoi diagram.
    :param rescue_time: A bool representing urgency of the rescue. If it is urgent (False), the algorithm
    will take a safer, but longer route. Otherwise (True), the algorithm will take a shorter, but riskier route.
    :return: A dictionary representing the weighted graph, with keys as vertex indices and values as lists of (neighbor_index, weight).
    """
    graph = {}
    epsilon = 1e-6

    for ridge in vor.ridge_vertices:
        if -1 in ridge:
            continue

        p1 = vor.vertices[ridge[0]]
        p2 = vor.vertices[ridge[1]]
        edge_length = np.linalg.norm(p1 - p2)
        midpoint = (p1 + p2) / 2.0

        clearance = min(np.linalg.norm(midpoint - site) for site in sites)
        clearance = max(clearance, epsilon)

        # Different ways to calculate the weight based on different values
        # final_weight = edge_length + (1.0 / clearance)
        # final_weight = edge_length + 5 * (1.0 / clearance)
        # final_weight = edge_length + (1.0 / (clearance ** 2)) I like this one best, because it over punishes closer points to be extra safe
        # final_weight = edge_length + np.exp(-clearance)
        if rescue_time:
            final_weight = edge_length + (1.0 / (clearance ** 2))
        else:
            final_weight = edge_length + (1.0 / clearance)

        graph.setdefault(ridge[0], {}).setdefault(ridge[1], final_weight)
        graph.setdefault(ridge[1], {}).setdefault(ridge[0], final_weight)

    return graph

def closest_vertex(point: np.ndarray, vor: Voronoi) -> list:
    """
    Finds the closest voronoi vertex to a point. Returns a list containing a numpy array of the vertex point in the first index
    and the vertex number in the second index.
    :param point: A point in the form of a numpy array
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi
    :return: A list that contains the vertex point and number
    """
    closest_vertex = min([[helper_distance(point, vertex), vertex, ind] for ind, vertex in enumerate(vor.vertices)])
    return (closest_vertex[1], closest_vertex[2])

def dijkstra(start_vertex: int, stop_vertex: int, vor: Voronoi, sites: np.ndarray, rescue_time: bool=True) -> list:
    """
    Computes the shortest path along the ridges of the voronoi diagram from the start_vertex to the stop_vertex.
    The path is returned as a list where the first index is the starting vertex and each subsequent index is the next vertex
    to be traveled to, ending with the stopping vertex.
    :param start_vertex: An integer corresponding with the number of the starting vertex
    :param stop_vertex: An integer corresponding with the number of the stopping vertex
    :param vor: A Voronoi diagram generated by scipy.spatial.Voronoi
    :param sites: A 2d numpy array of site coordinates
    :param rescue_time: A bool representing urgency of the rescue. If it is urgent (False), the algorithm
    will take a safer, but longer route. Otherwise (True), the algorithm will take a shorter, but riskier route.
    :return: A list of the path to be travelled
    """
    #https://www.datacamp.com/tutorial/dijkstra-algorithm-in-python
    #This website was used to help understand and implement the code
    distances = {node: float('inf') for node, vertex in enumerate(vor.vertices)}
    distances[start_vertex] = 0
    pq = [(0, start_vertex)]
    heapify(pq)
    visited = set()

    connected_vertices = build_weighted_graph(vor, sites, rescue_time)

    while pq:
        current_distance, current_node = heappop(pq)
        if current_node in visited:
            continue
        visited.add(current_node)

        for neighbor, weight in connected_vertices[current_node].items():
            tent_distance = current_distance + weight
            if tent_distance < distances[neighbor]:
                distances[neighbor] = tent_distance
                heappush(pq, (tent_distance, neighbor))

    pre = {node: None for node, vertex in enumerate(vor.vertices)}

    for node, distance in distances.items():
        for neighbor, weight in connected_vertices[node].items():
            if distances[neighbor] == distance + weight:
                pre[neighbor] = node

    path = []
    current_node = stop_vertex

    while current_node is not None:
        path.append(current_node)
        current_node = pre[current_node]

    path.reverse()
    return path

def path_finder(start: np.ndarray, stop: np.ndarray, vor: Voronoi, sites: np.ndarray, rescue_time: bool=True):
    """
    Computes the full path from starting point to stopping point, while traveling along the safest and most efficient route.
    :param start: A 1d numpy array containing a starting point
    :param stop: A 1d numpy array containing a stopping point
    :param vor: vor: A Voronoi diagram generated by scipy.spatial.Voronoi
    :param sites: A 2d numpy array of site coordinates
    :param rescue_time: A bool representing urgency of the rescue. If it is urgent (False), the algorithm
    will take a safer, but longer route. Otherwise (True), the algorithm will take a shorter, but riskier route.
    :return: A list of points in the order of pathing. Starting at the start point and ending at the stop point
    """
    starting_vertex = closest_vertex(start, vor)
    stopping_vertex = closest_vertex(stop, vor)
    vertex_path = dijkstra(starting_vertex[1], stopping_vertex[1], vor, sites, rescue_time)
    full_path = []
    full_path.append(start)
    for vertex in vertex_path:
        full_path.append(vor.vertices[vertex])
    full_path.append(stop)
    return full_path

def visualize_path(path: list, vor: Voronoi, sites: np.ndarray, padding: float=0.1) -> None:
    """
    Plots the Voronoi diagram and overlays a computed path.

    :param path: List of 2D points (as numpy arrays) starting with the start point and ending with the stop point.
    :param vor:  A scipy.spatial.Voronoi diagram.
    :param sites: A 2d numpy array of site coordinates
    :param padding: A float used to pad the edges of the plot
    """
    fig, ax = plt.subplots()
    voronoi_plot_2d(vor, ax=ax)

    xs = [pt[0] for pt in path]
    ys = [pt[1] for pt in path]

    ax.plot(xs, ys, '-r', linewidth=2)
    ax.plot(xs[0], ys[0], 'bo', label='Start')
    ax.plot(xs[-1], ys[-1], 'ro', label='Stop')

    x_vals = [pt[0] for pt in path] + list(vor.vertices[:,0]) + [pt[0] for pt in sites.tolist()]
    y_vals = [pt[1] for pt in path] + list(vor.vertices[:,1]) + [pt[1] for pt in sites.tolist()]

    x_min, x_max = min(x_vals), max(x_vals)
    y_min, y_max = min(y_vals), max(y_vals)

    x_pad = (x_max - x_min) * padding
    y_pad = (y_max - y_min) * padding

    ax.set_xlim(x_min - x_pad, x_max + x_pad)
    ax.set_ylim(y_min - y_pad, y_max + y_pad)

    ax.legend()
    plt.show()

def main():
    choice = input('Load from CSV? (y/n): ').lower()
    if choice == 'y':
        filename = input('Enter CSV file name: ')
        try:
            #This is a blueprint for loading a csv, will have to edit later
            sites, start, stop = load_risk_path_from_csv(filename)
            # sites = np.array(sites)
            # start = np.array(start)
            # stop = np.array(stop)
            print('csv')
        except FileNotFoundError:
            return print('File not found')
        except ValueError:
            return print('ValueError')
        except KeyError:
            return print('KeyError')
    else:
        sites = []
        site_num = input('How many sites are you entering? ')
        if not site_num.isdigit():
            return print('Error: Not a valid number')
        elif int(site_num) < 4:
            return print('Please enter more than 4 sites')
        for _ in range(int(site_num)):
            site_input = input('Input a valid site in the form (x,y): ')
            site_input = site_input.replace('(', '')
            site_input = site_input.replace(')', '')
            x, y = site_input.split(',')
            point = np.array([float(x), float(y)])
            sites.append(point)
        sites = np.array(sites)

        start_input = input('Input starting point in the form of (x,y): ')
        start_input = start_input.replace('(', '')
        start_input = start_input.replace(')', '')
        x, y = start_input.split(',')
        start = np.array([float(x), float(y)])

        stop_input = input('Input stopping point in the form of (x,y): ')
        stop_input = stop_input.replace('(', '')
        stop_input = stop_input.replace(')', '')
        x, y = stop_input.split(',')
        stop = np.array([float(x), float(y)])

        time_input = input('Is it urgent? (y/n): ')
        if time_input == 'y':
            rescue_time = False
        elif time_input == 'n':
            rescue_time = True
        else:
            return print('Error')

    vor = Voronoi(sites)
    path = path_finder(start, stop, vor, sites)
    visualize_path(path, vor, sites)
    question=input('Do you want to export the data? (y/n): ')
    if question == 'y':
        output_file = input("Enter output CSV file name to save the data: ")
        export_risk_path_to_csv(sites, start, stop, output_file)
        print(f"Data has been exported to {output_file}")
    else:
        pass

if __name__ == "__main__":
    main()